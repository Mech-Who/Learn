# 一、SOLID原则

## 1.1 S：单一职责原则（Single Responsibility Principle）

> “一个类应该仅仅只有一个被修改的理由。”

### 1.1.1 基本内容

  每一个类都应该只具有一种职责。

### 1.1.2 坏处

  1. 如果某个类违反了“单一职责原则”，那意味着我们经常会因为不同的原因去修改它。这可能会导致不同功能之间相互影响。
  2. 另外，单个类承担的职责越多，意味着这个类的复杂度也就越高，它的维护成本也同样会水涨船高。
  3. 违反“单一职责原则”的类同样也难以被复用

### 1.1.3 指导方案

  1. 把大类拆分为多个小类
  2. 使用函数

      “单一职责原则”虽然是针对类说的，但其实它的适用范围可以超出类本身。比如在 Python 中，通过定义函数，同样也可以让上面的代码符合单一职责原则。

      将“文件写入”职责拆分为新函数是一个 Python 特色的解决方案，它虽然没有那么 OO（面向对象），但是同样满足“单一职责原则”，而且在很多场景下更灵活与高效。

### 1.1.4 总结

- “S: 单一职责原则” 认为一个类只应该有一种被修改的原因
- 编写更小的类通常更不容易违反 S 原则
- S 原则同样适用于函数，你可以让函数和类协同工作

## 1.2 O：开放-关闭原则（Open-closed Principle）

> “类应该对扩展开放，对修改封闭。”
>
> “你应该可以在不修改某个类的前提下，扩展它的行为。”

### 1.2.1 基本内容

类应该通过扩展而不是修改的方式改变自己的行为。

### 1.2.2 指导方案

  1. 使用类继承来改造代码

      继承是面向对象理论中最重要的概念之一。它允许我们在父类中定义好数据和方法，然后通过继承的方式让子类获得这些内容，并可以选择性的对其中一些进行重写，修改它的行为。

      使用继承的方式来让类遵守“开放-关闭原则”的关键点在于：找到父类中会变动的部分，将其抽象成新的方法（或属性），最终允许新的子类来重写它以改变类的行为。

  2. 使用组合与依赖注入来改造代码

      虽然类的继承特性很强大，但它并非唯一办法，依赖注入（Dependency injection） 是解决这个问题的另一种思路。

      与继承不同，依赖注入允许我们在类实例化时，通过参数将业务逻辑的变化点：帖子过滤算法 注入到类实例中。最终同样实现“开放-关闭原则”。

  3. 使用数据驱动思想来改造代码

      在实现“开放-关闭”原则的众多手法中，除了继承与依赖注入外，还有一种经常被用到的方式：“数据驱动”。这个方式的核心思想在于：将经常变动的东西，完全以数据的方式抽离出来。当需求变动时，只改动数据，代码逻辑保持不动。

      它的原理与“依赖注入”有一些相似，同样是把变化的东西抽离到类外部。不同的是，后者抽离的通常是类，而前者抽离的是数据。

      与前面的继承和依赖注入方式相比，“数据驱动”的代码更简洁，不需要定义额外的类。但它同样也存在缺点：它的可定制性不如前面的两种方式。

  如何选择合适的方式来让代码符合“开放-关闭原则”，需要根据具体的需求和场景来判断。这也是一个无法一蹴而就、需要大量练习和经验积累的过程。

### 1.2.3 总结

- “O: 开放-关闭原则” 认为类应该对改动关闭，对扩展开放
- 找到需求中频繁变化的那个点，是让类遵循 O 原则的重点所在
- 使用子类继承的方式可以让类遵守 O 原则
- 通过定义算法类，并进行依赖注入，也可以让类遵循 O 原则
- 将数据与逻辑分离，使用数据驱动的方式也是改造代码的好办法

## 1.3 L：里氏替换原则（Liskov Substitution Principle）与继承

> “当你使用继承时，子类（派生类）对象应该可以在程序中替代父类（基类）对象使用，而不破坏程序原本的功能。”

### 1.3.1 基本内容

  和前面两条非常抽象的原则不同，“里氏替换原则”是一条非常具体的，和类继承有关的原则。

  在 OOP 世界里，继承算是一个非常特殊的存在，它有点像一把无坚不摧的双刃剑，强大且危险。合理使用继承，可以大大减少类与类之间的重复代码，让程序事半功倍，而不当的继承关系，则会让类与类之间建立起错误的强耦合，带来大片难以理解和维护的代码。

  正是因为这样，对继承的态度也可以大致分为两类。大多数人认为，继承和多态、封装等特性一样，属于面向对象编程的几大核心特征之一。而同时有另一部分人觉得，继承带来的 坏处远比好处多。甚至在 Go 这门相对年轻的编程语言里，设计者直接去掉了继承，提倡完全使用组合来替代。

  从我个人的编程经验来看，继承确实极易被误用。要设计出合理的继承关系，是一件需要深思熟虑的困难事儿。不过幸运的是，在这方面，"里氏替换原则"(后简称 L 原则) 为我们提供了非常好的指导意义。

### 1.3.2 指导方案

  SOLID 里的每条原则并非完全独立的个体，它们之间其实互有联系。

  1. 重新设计类之间的继承关系。

      具体点来说，子类不能只是简单通过抛出异常的方式对某个类方法进行“退化”。如果 “对象不能支持某种操作” 本身就是这个类型的 核心特征 之一，那我们在进行父类设计时，就应该把这个 核心特征 设计进去。

### 1.3.3 总结

## 1.4 依赖倒转

## 1.5 接口倒置
